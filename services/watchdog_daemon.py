# Auto-generated by Codex agent on 2025-12-01T00:27:00Z
#!/usr/bin/env python3
"""Lightweight watchdog daemon that logs RSS and can restart a process on threshold breach."""

import argparse
import csv
import datetime as dt
import json
import os
import shlex
import subprocess
import sys
import time
from pathlib import Path
from typing import List, Sequence, Tuple

try:
    import psutil  # type: ignore
except ImportError:  # pragma: no cover - psutil optional
    psutil = None


def _now() -> str:
    return dt.datetime.utcnow().isoformat() + "Z"


def _ensure_parent(path: Path) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)


def write_log(log_path: Path, message: str) -> None:
    _ensure_parent(log_path)
    with log_path.open("a", encoding="utf-8") as fh:
        fh.write(f"{_now()}\t{message}\n")


def load_config(path: Path) -> dict:
    with path.open("r", encoding="utf-8") as fh:
        return json.load(fh)


def parse_command(cmd: Sequence[str] | str) -> List[str]:
    if isinstance(cmd, str):
        return shlex.split(cmd)
    return [str(part) for part in cmd]


def _collect_psutil(name: str) -> List[Tuple[int, float]]:
    assert psutil is not None
    matches: List[Tuple[int, float]] = []
    for proc in psutil.process_iter(["name", "pid", "memory_info"]):
        proc_name = (proc.info.get("name") or "").lower()
        if proc_name != name.lower():
            continue
        try:
            rss_mb = float(proc.info["memory_info"].rss) / (1024 * 1024)
            matches.append((int(proc.info["pid"]), rss_mb))
        except Exception:
            continue
    return matches


def _collect_platform_ps(name: str) -> List[Tuple[int, float]]:
    matches: List[Tuple[int, float]] = []
    if os.name == "nt":
        cmd = ["tasklist", "/fo", "csv", "/nh"]
        result = subprocess.run(cmd, capture_output=True, text=True, check=False)
        reader = csv.reader(result.stdout.splitlines())
        for row in reader:
            if not row:
                continue
            image_name = row[0].strip('"').lower()
            if image_name != name.lower() and image_name != f"{name.lower()}.exe":
                continue
            pid = int(row[1])
            mem_usage = row[4].replace(",", "").replace("K", "").strip()
            try:
                rss_mb = float(mem_usage) / 1024
            except ValueError:
                continue
            matches.append((pid, rss_mb))
    else:
        cmd = ["ps", "-eo", "pid,comm,rss"]
        result = subprocess.run(cmd, capture_output=True, text=True, check=False)
        for line in result.stdout.splitlines()[1:]:
            parts = line.split()
            if len(parts) < 3:
                continue
            pid_str, comm, rss_kb = parts[0], parts[1], parts[2]
            if comm != name and os.path.basename(comm) != name:
                continue
            try:
                pid = int(pid_str)
                rss_mb = float(rss_kb) / 1024
            except ValueError:
                continue
            matches.append((pid, rss_mb))
    return matches


def collect_process_rss(name: str) -> List[Tuple[int, float]]:
    if psutil:
        return _collect_psutil(name)
    return _collect_platform_ps(name)


def maybe_write_marker(marker_path: Path, message: str) -> None:
    _ensure_parent(marker_path)
    marker_path.write_text(f"{_now()}\t{message}\n", encoding="utf-8")


def attempt_start(start_cmd: List[str], dry_run: bool, log_path: Path) -> None:
    cmd_display = " ".join(start_cmd)
    if dry_run:
        write_log(log_path, f"dry-run: would start command -> {cmd_display}")
        return
    try:
        proc = subprocess.Popen(start_cmd)
        write_log(log_path, f"started command pid={proc.pid} cmd={cmd_display}")
    except Exception as exc:  # pragma: no cover - defensive
        write_log(log_path, f"failed to start command: {exc}")


def loop(config_path: Path, dry_run: bool) -> None:
    if not config_path.exists():
        raise FileNotFoundError(f"config not found: {config_path}")

    config = load_config(config_path)
    process_name = config.get("process_name", "")
    threshold_mb = float(config.get("threshold_mb", 0))
    poll_seconds = int(config.get("poll_seconds", 30))
    start_cmd = parse_command(config.get("start_command", []))
    log_path = Path(config.get("log_path", "reports/watchdog_daemon.log"))
    marker_path = Path(config.get("marker_path", "reports/watchdog_restart.marker"))

    if not process_name:
        raise ValueError("process_name missing in watchdog config")
    if not start_cmd:
        raise ValueError("start_command missing in watchdog config")

    write_log(log_path, f"watchdog started (process={process_name}, threshold_mb={threshold_mb}, dry_run={dry_run})")

    while True:
        processes = collect_process_rss(process_name)
        rss_total = sum(rss for _, rss in processes)
        pid_list = ",".join(str(pid) for pid, _ in processes) or "none"
        write_log(
            log_path,
            f"sample rss_total_mb={rss_total:.2f} threshold_mb={threshold_mb} pids={pid_list}",
        )

        if threshold_mb > 0 and rss_total > threshold_mb:
            msg = f"threshold exceeded rss_total_mb={rss_total:.2f} threshold_mb={threshold_mb}"
            maybe_write_marker(marker_path, msg)
            write_log(log_path, f"{msg}; invoking start_command")
            attempt_start(start_cmd, dry_run, log_path)

        time.sleep(max(poll_seconds, 1))


def main(argv: Sequence[str] | None = None) -> int:
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument("--config", default="config/watchdog_config.json", help="Path to watchdog config JSON")
    parser.add_argument("--dry-run", action="store_true", help="Log actions without starting processes")
    args = parser.parse_args(argv)

    config_path = Path(args.config)
    try:
        loop(config_path, args.dry_run)
    except KeyboardInterrupt:
        write_log(Path("reports/watchdog_daemon.log"), "watchdog interrupted by user")
        return 0
    except Exception as exc:
        write_log(Path("reports/watchdog_daemon.log"), f"watchdog failed: {exc}")
        return 1
    return 0


if __name__ == "__main__":
    sys.exit(main())
