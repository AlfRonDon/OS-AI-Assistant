diff --git a/config/watchdog_config.json b/config/watchdog_config.json
new file mode 100644
index 0000000..9d47343
--- /dev/null
+++ b/config/watchdog_config.json
@@ -0,0 +1,13 @@
+{
+  "_generated_by": "codex-agent auto-generated 2025-12-01T00:27:00Z",
+  "process_name": "edge_model_runner",
+  "threshold_mb": 14336,
+  "poll_seconds": 30,
+  "start_command": [
+    "pwsh",
+    "-File",
+    "scripts/watchdog_service_wrapper.ps1"
+  ],
+  "log_path": "reports/watchdog_daemon.log",
+  "marker_path": "reports/watchdog_restart.marker"
+}
diff --git a/deploy/edgeos-watchdog.service.template b/deploy/edgeos-watchdog.service.template
new file mode 100644
index 0000000..be2dd85
--- /dev/null
+++ b/deploy/edgeos-watchdog.service.template
@@ -0,0 +1,17 @@
+# Auto-generated by Codex agent on 2025-12-01T00:27:00Z
+[Unit]
+Description=EdgeOS Watchdog daemon (Python)
+After=network.target
+
+[Service]
+Type=simple
+WorkingDirectory=${REPO}
+ExecStart=/usr/bin/env python3 ${REPO}/services/watchdog_daemon.py --config ${REPO}/config/watchdog_config.json
+Restart=always
+RestartSec=5
+Environment=PYTHONUNBUFFERED=1
+StandardOutput=append:${REPO}/reports/watchdog_daemon.log
+StandardError=append:${REPO}/reports/watchdog_daemon.log
+
+[Install]
+WantedBy=multi-user.target
diff --git a/deploy/watchdog_nssm_instructions.txt b/deploy/watchdog_nssm_instructions.txt
new file mode 100644
index 0000000..5543ecc
--- /dev/null
+++ b/deploy/watchdog_nssm_instructions.txt
@@ -0,0 +1,20 @@
+# Auto-generated by Codex agent on 2025-12-01T00:27:00Z
+Use these commands in an elevated PowerShell on Windows to wrap the watchdog daemon with NSSM.
+
+1. Ensure `nssm.exe` and `python.exe` are in PATH.
+2. From the repo root:
+   ```
+   $repo = (Get-Location).Path
+   nssm install EdgeOSWatchdog "python.exe" "$repo\\services\\watchdog_daemon.py"
+   nssm set EdgeOSWatchdog AppParameters "--config `"$repo\\config\\watchdog_config.json`""
+   nssm set EdgeOSWatchdog AppStdout "$repo\\reports\\watchdog_daemon.log"
+   nssm set EdgeOSWatchdog AppStderr "$repo\\reports\\watchdog_daemon.log"
+   nssm set EdgeOSWatchdog Start SERVICE_AUTO_START
+   nssm start EdgeOSWatchdog
+   ```
+3. Enable dry-run mode if you only want logging: add `--dry-run` to `AppParameters`.
+4. Remove service later:
+   ```
+   nssm stop EdgeOSWatchdog
+   nssm remove EdgeOSWatchdog confirm
+   ```
diff --git a/services/watchdog_daemon.py b/services/watchdog_daemon.py
new file mode 100644
index 0000000..184f396
--- /dev/null
+++ b/services/watchdog_daemon.py
@@ -0,0 +1,180 @@
+# Auto-generated by Codex agent on 2025-12-01T00:27:00Z
+#!/usr/bin/env python3
+"""Lightweight watchdog daemon that logs RSS and can restart a process on threshold breach."""
+
+import argparse
+import csv
+import datetime as dt
+import json
+import os
+import shlex
+import subprocess
+import sys
+import time
+from pathlib import Path
+from typing import List, Sequence, Tuple
+
+try:
+    import psutil  # type: ignore
+except ImportError:  # pragma: no cover - psutil optional
+    psutil = None
+
+
+def _now() -> str:
+    return dt.datetime.utcnow().isoformat() + "Z"
+
+
+def _ensure_parent(path: Path) -> None:
+    path.parent.mkdir(parents=True, exist_ok=True)
+
+
+def write_log(log_path: Path, message: str) -> None:
+    _ensure_parent(log_path)
+    with log_path.open("a", encoding="utf-8") as fh:
+        fh.write(f"{_now()}\t{message}\n")
+
+
+def load_config(path: Path) -> dict:
+    with path.open("r", encoding="utf-8") as fh:
+        return json.load(fh)
+
+
+def parse_command(cmd: Sequence[str] | str) -> List[str]:
+    if isinstance(cmd, str):
+        return shlex.split(cmd)
+    return [str(part) for part in cmd]
+
+
+def _collect_psutil(name: str) -> List[Tuple[int, float]]:
+    assert psutil is not None
+    matches: List[Tuple[int, float]] = []
+    for proc in psutil.process_iter(["name", "pid", "memory_info"]):
+        proc_name = (proc.info.get("name") or "").lower()
+        if proc_name != name.lower():
+            continue
+        try:
+            rss_mb = float(proc.info["memory_info"].rss) / (1024 * 1024)
+            matches.append((int(proc.info["pid"]), rss_mb))
+        except Exception:
+            continue
+    return matches
+
+
+def _collect_platform_ps(name: str) -> List[Tuple[int, float]]:
+    matches: List[Tuple[int, float]] = []
+    if os.name == "nt":
+        cmd = ["tasklist", "/fo", "csv", "/nh"]
+        result = subprocess.run(cmd, capture_output=True, text=True, check=False)
+        reader = csv.reader(result.stdout.splitlines())
+        for row in reader:
+            if not row:
+                continue
+            image_name = row[0].strip('"').lower()
+            if image_name != name.lower() and image_name != f"{name.lower()}.exe":
+                continue
+            pid = int(row[1])
+            mem_usage = row[4].replace(",", "").replace("K", "").strip()
+            try:
+                rss_mb = float(mem_usage) / 1024
+            except ValueError:
+                continue
+            matches.append((pid, rss_mb))
+    else:
+        cmd = ["ps", "-eo", "pid,comm,rss"]
+        result = subprocess.run(cmd, capture_output=True, text=True, check=False)
+        for line in result.stdout.splitlines()[1:]:
+            parts = line.split()
+            if len(parts) < 3:
+                continue
+            pid_str, comm, rss_kb = parts[0], parts[1], parts[2]
+            if comm != name and os.path.basename(comm) != name:
+                continue
+            try:
+                pid = int(pid_str)
+                rss_mb = float(rss_kb) / 1024
+            except ValueError:
+                continue
+            matches.append((pid, rss_mb))
+    return matches
+
+
+def collect_process_rss(name: str) -> List[Tuple[int, float]]:
+    if psutil:
+        return _collect_psutil(name)
+    return _collect_platform_ps(name)
+
+
+def maybe_write_marker(marker_path: Path, message: str) -> None:
+    _ensure_parent(marker_path)
+    marker_path.write_text(f"{_now()}\t{message}\n", encoding="utf-8")
+
+
+def attempt_start(start_cmd: List[str], dry_run: bool, log_path: Path) -> None:
+    cmd_display = " ".join(start_cmd)
+    if dry_run:
+        write_log(log_path, f"dry-run: would start command -> {cmd_display}")
+        return
+    try:
+        proc = subprocess.Popen(start_cmd)
+        write_log(log_path, f"started command pid={proc.pid} cmd={cmd_display}")
+    except Exception as exc:  # pragma: no cover - defensive
+        write_log(log_path, f"failed to start command: {exc}")
+
+
+def loop(config_path: Path, dry_run: bool) -> None:
+    if not config_path.exists():
+        raise FileNotFoundError(f"config not found: {config_path}")
+
+    config = load_config(config_path)
+    process_name = config.get("process_name", "")
+    threshold_mb = float(config.get("threshold_mb", 0))
+    poll_seconds = int(config.get("poll_seconds", 30))
+    start_cmd = parse_command(config.get("start_command", []))
+    log_path = Path(config.get("log_path", "reports/watchdog_daemon.log"))
+    marker_path = Path(config.get("marker_path", "reports/watchdog_restart.marker"))
+
+    if not process_name:
+        raise ValueError("process_name missing in watchdog config")
+    if not start_cmd:
+        raise ValueError("start_command missing in watchdog config")
+
+    write_log(log_path, f"watchdog started (process={process_name}, threshold_mb={threshold_mb}, dry_run={dry_run})")
+
+    while True:
+        processes = collect_process_rss(process_name)
+        rss_total = sum(rss for _, rss in processes)
+        pid_list = ",".join(str(pid) for pid, _ in processes) or "none"
+        write_log(
+            log_path,
+            f"sample rss_total_mb={rss_total:.2f} threshold_mb={threshold_mb} pids={pid_list}",
+        )
+
+        if threshold_mb > 0 and rss_total > threshold_mb:
+            msg = f"threshold exceeded rss_total_mb={rss_total:.2f} threshold_mb={threshold_mb}"
+            maybe_write_marker(marker_path, msg)
+            write_log(log_path, f"{msg}; invoking start_command")
+            attempt_start(start_cmd, dry_run, log_path)
+
+        time.sleep(max(poll_seconds, 1))
+
+
+def main(argv: Sequence[str] | None = None) -> int:
+    parser = argparse.ArgumentParser(description=__doc__)
+    parser.add_argument("--config", default="config/watchdog_config.json", help="Path to watchdog config JSON")
+    parser.add_argument("--dry-run", action="store_true", help="Log actions without starting processes")
+    args = parser.parse_args(argv)
+
+    config_path = Path(args.config)
+    try:
+        loop(config_path, args.dry_run)
+    except KeyboardInterrupt:
+        write_log(Path("reports/watchdog_daemon.log"), "watchdog interrupted by user")
+        return 0
+    except Exception as exc:
+        write_log(Path("reports/watchdog_daemon.log"), f"watchdog failed: {exc}")
+        return 1
+    return 0
+
+
+if __name__ == "__main__":
+    sys.exit(main())


